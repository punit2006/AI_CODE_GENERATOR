# -*- coding: utf-8 -*-
"""AI-CODE-GENERATOR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uhOg_LiZFyQl9QdQ3Jgu1k77I9pQNyU_
"""

!pip install -U langchain-groq -U langchain-community pypdf pypdf2 sentence-transformers faiss-cpu wikipedia google-search-results

# ‚úÖ Groq-Powered Code Generator with Suggestions in One Cell

# Install required packages (if not already installed)
!pip install --quiet langchain langchain-groq

# ‚úÖ All-in-One Script Starts Here
from langchain.chains import LLMChain
from langchain.prompts import PromptTemplate
from langchain_groq import ChatGroq

try:
    from google.colab import userdata
except ImportError:
    raise ImportError("‚ö†Ô∏è This script is designed to run in Google Colab with secrets managed via 'google.colab.userdata'.")

# ‚úÖ STEP 1: Load API key
groq_api_key = userdata.get("MYNAME")  # Replace 'MYNAME' with your key alias in Colab secrets
if not groq_api_key:
    raise ValueError("‚ùå 'MYNAME' not found in Colab secrets. Use: userdata.set('MYNAME', 'your_groq_api_key')")

# ‚úÖ STEP 2: Initialize LLM
llm = ChatGroq(
    temperature=0,
    model_name="llama3-8b-8192",
    groq_api_key=groq_api_key
)

# ‚úÖ STEP 3: Code generation prompt
code_prompt = PromptTemplate(
    input_variables=["language", "task"],
    template="""
You are an expert programmer AI tasked with generating clean, efficient, and well-commented code in {language}.

**Task:** {task}

**Instructions:**
- Write efficient, readable code with meaningful comments.
- Ensure it can be executed without errors.
- Provide sample output for the code if applicable.
- If assumptions are made, list them as comments.
- End with a short explanation of why {language} is suitable for this task.
- Give them 2 points about the improvements in the program.
"""
)

# ‚úÖ STEP 4: Suggestion prompt
suggestion_prompt = PromptTemplate(
    input_variables=["code", "language", "task"],
    template="""
You are an expert code reviewer AI.

Here is the task: {task}
Language: {language}

Here is the current generated code:
```{language}
{code}
""" )

#STEP 5: Chain setup
code_chain = LLMChain(llm=llm, prompt=code_prompt)
suggestion_chain = LLMChain(llm=llm, prompt=suggestion_prompt)

#STEP 6: User Input
task = input("üìù Enter your coding task: ")
language = input("üíª Enter the programming language: ")

generated_code = code_chain.run(task=task, language=language)
print("\n‚úÖ Generated Code:\n")
print(generated_code)

import re

# ‚úÖ Split suggestion text into list
def parse_suggestions(text):
    # Split on numbered list (e.g. 1. or 1Ô∏è‚É£) using regex
    parts = re.split(r"\n\s*(?:\d[\.:Ô∏è‚É£])\s*", text.strip())
    return [s.strip() for s in parts if s]

while True:
    choice = input("\nü§ñ What would you like to do next?\n"
                   "1Ô∏è‚É£ Get suggestions for the code\n"
                   "2Ô∏è‚É£ Generate code with suggestions\n" # New option added here
                   "3Ô∏è‚É£ Edit the code manually\n"
                   "4Ô∏è‚É£ Generate another code\n"
                   "5Ô∏è‚É£ Let the model make a change you define\n"
                   "6Ô∏è‚É£ Exit\n" # Updated exit option number
                   "Enter 1, 2, 3, 4, 5, or 6: ").strip() # Updated input prompt

    if choice == "1":
        # ‚úÖ Generate and print suggestions
        suggestions = suggestion_chain.run(code=generated_code, language=language, task=task)
        print("\nüí° Suggested Improvements:\n")
        print(suggestions)

    elif choice == "2": # New option functionality
        print("\nüîÑ Generating code with suggestions...")
        # Assuming 'suggestions' variable holds the last generated suggestions
        if 'suggestions' in locals() and suggestions:
            updated_task = f"{task}\n\nIncorporate the following suggestions:\n{suggestions}"
            generated_code = code_chain.run(task=updated_task, language=language)
            print("\n‚úÖ Updated Code:\n")
            print(generated_code)
        else:
            print("‚ùå No suggestions available yet. Please select option 1 first.")

    elif choice == "3": # Updated option number
        print("\nüîß Edit the code below. When you're done, copy and paste it back here.")
        print("-" * 30)
        print(generated_code)
        print("-" * 30)
        edited_code = input("Paste your edited code here: ")
        generated_code = edited_code # Update the generated_code with the user's edited version
        print("\n‚úÖ Code updated with your manual changes.")


    elif choice == "4": # Updated option number
        # ‚úÖ Get new user input and generate code again
        task = input("üìù Enter your new coding task: ")
        language = input("üíª Enter the programming language for the new task: ")
        generated_code = code_chain.run(task=task, language=language)
        print("\n‚úÖ Generated Code:\n")
        print(generated_code)

    elif choice == "5": # Updated option number
        custom = input("üîß Enter the change you want the model to make: ")
        task += f"\n\nUpdate Request: {custom}" # Add the custom request to the task for the model

        # ‚úÖ Regenerate updated code
        generated_code = code_chain.run(task=task, language=language)
        print("\nüîÅ Updated Code based on your request:\n")
        print(generated_code)

    elif choice == "6": # Updated exit option number
        print("\n‚úÖ Final Code Output:\n")
        print(generated_code)
        print("\nüëã Exiting... Have a productive coding session!")
        break

    else:
        print("‚ùå Invalid input. Please enter 1, 2, 3, 4, 5, or 6.") # Updated invalid input message

import os

# Create the .streamlit directory if it doesn't exist
if not os.path.exists('.streamlit'):
    os.makedirs('.streamlit')

# Write the secrets.toml file
# IMPORTANT: Replace 'YOUR_ACTUAL_GROQ_API_KEY' with your real Groq API key
secrets_content = """
MYNAME = "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"
"""

with open('.streamlit/secrets.toml', 'w') as f:
    f.write(secrets_content)

print("Created .streamlit/secrets.toml with a placeholder for the MYNAME secret.")
print("IMPORTANT: Please edit the .streamlit/secrets.toml file and replace 'YOUR_ACTUAL_GROQ_API_KEY' with your actual Groq API key.")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# 
# st.title("Groq-Powered Code Generator with Suggestions")
# 
# st.write("""
# This application uses the Groq API to generate code based on your task and language specifications.
# You can also get suggestions for the generated code and iterate on it.
# """)

# Commented out IPython magic to ensure Python compatibility.
# %%writefile -a app.py
# 
# task = st.text_area("Enter your coding task:")
# language = st.text_input("Enter the programming language:")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile -a app.py
# import os
# from langchain.chains import LLMChain
# from langchain.prompts import PromptTemplate
# from langchain_groq import ChatGroq
# import streamlit as st
# 
# # Assume the API key is available as an environment variable or Streamlit secret
# groq_api_key = os.getenv("MYNAME") or st.secrets["MYNAME"]
# 
# if not groq_api_key:
#     st.error("GROQ_API_KEY not found. Please set it in your environment variables or Streamlit secrets.")
# else:
#     # Define and initialize LLM
#     llm = ChatGroq(
#         temperature=0,
#         model_name="llama3-8b-8192",
#         groq_api_key=groq_api_key
#     )
# 
#     # Define code generation prompt
#     code_prompt = PromptTemplate(
#         input_variables=["language", "task"],
#         template="""
#     You are an expert programmer AI tasked with generating clean, efficient, and well-commented code in {language}.
# 
#     **Task:** {task}
# 
#     **Instructions:**
#     - Write efficient, readable code with meaningful comments.
#     - Ensure it can be executed without errors.
#     - Provide sample output for the code if applicable.
#     - If assumptions are made, list them as comments.
#     - End with a short explanation of why {language} is suitable for this task.
#     - Give them 2 points about the improvements in the program.
#     """
#     )
# 
#     # Create LLMChain
#     code_chain = LLMChain(llm=llm, prompt=code_prompt)
# 
#     # Button to trigger code generation
#     if st.button("Generate Code"):
#         if task and language:
#             with st.spinner("Generating code..."):
#                 generated_code = code_chain.run(task=task, language=language)
#                 st.session_state.generated_code = generated_code
#             st.subheader("Generated Code:")
#             st.code(st.session_state.generated_code, language=language)
#         else:
#             st.warning("Please enter both a coding task and a programming language.")
# 
#     # Display generated code if already exists in session state
#     if 'generated_code' in st.session_state:
#         st.subheader("Generated Code:")
#         st.code(st.session_state.generated_code, language=language)
#

# Commented out IPython magic to ensure Python compatibility.
# %%writefile -a app.py
# 
# # Define suggestion prompt
# suggestion_prompt = PromptTemplate(
#     input_variables=["code", "language", "task"],
#     template="""
# You are an expert code reviewer AI.
# 
# Here is the task: {task}
# Language: {language}
# 
# Here is the current generated code:
# ```{language}
# {code}
# """ )
# 
# # Create LLMChain for suggestions
# suggestion_chain = LLMChain(llm=llm, prompt=suggestion_prompt)
# 
# # Button to trigger suggestion generation
# if 'generated_code' in st.session_state:
#     if st.button("Get Suggestions"):
#         with st.spinner("Generating suggestions..."):
#             suggestions = suggestion_chain.run(
#                 code=st.session_state.generated_code,
#                 language=language,
#                 task=task
#             )
#             st.session_state.suggestions = suggestions
#         st.subheader("Suggested Improvements:")
#         st.info(st.session_state.suggestions)
# 
# # Display suggestions if already exists in session state
# if 'suggestions' in st.session_state:
#     st.subheader("Suggested Improvements:")
#     st.info(st.session_state.suggestions)
#

# Commented out IPython magic to ensure Python compatibility.
# %%writefile -a app.py
# 
# # Options for further interaction
# if 'generated_code' in st.session_state:
#     st.subheader("Choose your next action:")
#     option = st.radio(
#         "Select an option:",
#         ('Get suggestions', 'Generate code with suggestions', 'Edit the code manually', 'Generate another code', 'Let the model make a change you define', 'Exit/Final Code'),
#         key='user_option'
#     )

# Commented out IPython magic to ensure Python compatibility.
# %%writefile -a app.py
# 
# if 'user_option' in st.session_state:
#     option = st.session_state.user_option
# 
#     if option == 'Get suggestions':
#         if 'generated_code' in st.session_state:
#             with st.spinner("Generating suggestions..."):
#                 suggestions = suggestion_chain.run(
#                     code=st.session_state.generated_code,
#                     language=language,
#                     task=task
#                 )
#                 st.session_state.suggestions = suggestions
#             st.subheader("Suggested Improvements:")
#             st.info(st.session_state.suggestions)
#         else:
#             st.warning("Please generate code first to get suggestions.")
# 
#     elif option == 'Generate code with suggestions':
#         if 'suggestions' in st.session_state:
#             st.subheader("Generating code with suggestions...")
#             updated_task = f"{task}\n\nIncorporate the following suggestions:\n{st.session_state.suggestions}"
#             with st.spinner("Generating updated code..."):
#                 generated_code = code_chain.run(task=updated_task, language=language)
#                 st.session_state.generated_code = generated_code
#             st.subheader("Updated Code:")
#             st.code(st.session_state.generated_code, language=language)
#         else:
#             st.warning("Please get suggestions first before generating code with suggestions.")
# 
#     elif option == 'Edit the code manually':
#         st.subheader("Edit the code below:")
#         edited_code = st.text_area("Edit Code", value=st.session_state.generated_code, height=400, key='edited_code_area')
#         if st.button("Apply Manual Edits"):
#             st.session_state.generated_code = edited_code
#             st.success("Code updated with your manual changes.")
#             st.experimental_rerun() # Rerun to show updated code immediately
# 
#     elif option == 'Generate another code':
#         st.subheader("Generate Another Code:")
#         new_task = st.text_area("Enter the new coding task:", key='new_task_input')
#         new_language = st.text_input("Enter the new programming language:", key='new_language_input')
#         if st.button("Generate New Code"):
#             if new_task and new_language:
#                 with st.spinner("Generating new code..."):
#                     generated_code = code_chain.run(task=new_task, language=new_language)
#                     st.session_state.generated_code = generated_code
#                     st.session_state.task = new_task # Update task and language in state
#                     st.session_state.language = new_language
#                     if 'suggestions' in st.session_state:
#                          del st.session_state.suggestions # Clear old suggestions
#                 st.subheader("Newly Generated Code:")
#                 st.code(st.session_state.generated_code, language=new_language)
#             else:
#                 st.warning("Please enter both a new coding task and a programming language.")
# 
# 
#     elif option == 'Let the model make a change you define':
#         st.subheader("Request a Custom Change:")
#         custom_change = st.text_area("Describe the change you want the model to make:", key='custom_change_input')
#         if st.button("Apply Custom Change"):
#             if custom_change:
#                  # Append custom change to the existing task for the model
#                 updated_task_with_custom = f"{st.session_state.task}\n\nUpdate Request: {custom_change}"
#                 with st.spinner("Applying custom change..."):
#                     generated_code = code_chain.run(task=updated_task_with_custom, language=st.session_state.language)
#                     st.session_state.generated_code = generated_code
#                     st.session_state.task = updated_task_with_custom # Update task in state
#                     if 'suggestions' in st.session_state:
#                         del st.session_state.suggestions # Clear old suggestions
#                 st.subheader("Code with Custom Change:")
#                 st.code(st.session_state.generated_code, language=st.session_state.language)
#             else:
#                 st.warning("Please describe the custom change you want.")
# 
#     elif option == 'Exit/Final Code':
#         st.subheader("Final Code Output:")
#         if 'generated_code' in st.session_state:
#             st.code(st.session_state.generated_code, language=language)
#         else:
#             st.info("No code has been generated yet.")
#         st.write("Exiting... Have a productive coding session!")
#

# Commented out IPython magic to ensure Python compatibility.
# %%writefile -a app.py
# 
# # The logic for 'Exit/Final Code' is already implemented in the previous step.
# # Reviewing the existing code block to ensure it correctly displays the final code.
# # The code block for 'Exit/Final Code' within the 'if option == ...' structure is:
# # elif option == 'Exit/Final Code':
# #     st.subheader("Final Code Output:")
# #     if 'generated_code' in st.session_state:
# #         st.code(st.session_state.generated_code, language=language)
# #     else:
# #         st.info("No code has been generated yet.")
# #     st.write("Exiting... Have a productive coding session!")
# 
# # This code correctly checks if 'generated_code' exists in session state,
# # displays a subheader "Final Code Output:", uses st.code() for syntax highlighting
# # with the correct language (assuming 'language' is still available in scope or state),
# # and provides an exit message.
# # No changes are needed based on the instructions.

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import os
# from langchain.chains import LLMChain
# from langchain.prompts import PromptTemplate
# from langchain_groq import ChatGroq
# 
# st.title("Groq-Powered Code Generator with Suggestions")
# 
# st.write("""
# This application uses the Groq API to generate code based on your task and language specifications.
# You can also get suggestions for the generated code and iterate on it.
# """)
# 
# # Ensure task and language inputs are always available
# task = st.text_area("Enter your coding task:", key='task_input')
# language = st.text_input("Enter the programming language:", key='language_input')
# 
# # Assume the API key is available as an environment variable or Streamlit secret
# # Use st.secrets for better security in Streamlit Cloud
# try:
#     groq_api_key = st.secrets["MYNAME"]
# except KeyError:
#     groq_api_key = os.getenv("MYNAME")
# 
# if not groq_api_key:
#     st.error("GROQ_API_KEY not found. Please set it in your environment variables or Streamlit secrets.")
# else:
#     # Define and initialize LLM
#     llm = ChatGroq(
#         temperature=0,
#         model_name="llama3-8b-8192",
#         groq_api_key=groq_api_key
#     )
# 
#     # Define code generation prompt
#     code_prompt = PromptTemplate(
#         input_variables=["language", "task"],
#         template="""
# You are an expert programmer AI tasked with generating clean, efficient, and well-commented code in {language}.
# 
# **Task:** {task}
# 
# **Instructions:**
# - Write efficient, readable code with meaningful comments.
# - Ensure it can be executed without errors.
# - Provide sample output for the code if applicable.
# - If assumptions are made, list them as comments.
# - End with a short explanation of why {language} is suitable for this task.
# - Give them 2 points about the improvements in the program.
# """
#     )
# 
#     # Create LLMChain for code generation
#     code_chain = LLMChain(llm=llm, prompt=code_prompt)
# 
#     # Define suggestion prompt
#     suggestion_prompt = PromptTemplate(
#         input_variables=["code", "language", "task"],
#         template="""
# You are an expert code reviewer AI.
# 
# Here is the task: {task}
# Language: {language}
# 
# Here is the current generated code:
# ```{language}
# {code}
# """ )
# 
#     # Create LLMChain for suggestions
#     suggestion_chain = LLMChain(llm=llm, prompt=suggestion_prompt)
# 
# 
#     # Button to trigger initial code generation
#     if st.button("Generate Code", key='generate_initial_code_button'):
#         if task and language:
#             with st.spinner("Generating code..."):
#                 generated_code = code_chain.run(task=task, language=language)
#                 st.session_state.generated_code = generated_code
#                 st.session_state.task = task # Store task and language in state
#                 st.session_state.language = language
#                 if 'suggestions' in st.session_state:
#                      del st.session_state.suggestions # Clear old suggestions
#             st.subheader("Generated Code:")
#             st.code(st.session_state.generated_code, language=st.session_state.language)
#         else:
#             st.warning("Please enter both a coding task and a programming language.")
# 
#     # Display generated code if already exists in session state
#     if 'generated_code' in st.session_state:
#         st.subheader("Current Code:")
#         # Use language from session state for syntax highlighting
#         st.code(st.session_state.generated_code, language=st.session_state.language)
# 
#         # Options for further interaction
#         st.subheader("Choose your next action:")
#         option = st.radio(
#             "Select an option:",
#             ('Get suggestions', 'Generate code with suggestions', 'Edit the code manually', 'Generate another code', 'Let the model make a change you define', 'Exit/Final Code'),
#             key='user_option'
#         )
# 
#         # Handle option logic based on the selected option
#         if option == 'Get suggestions':
#             if 'suggestions' not in st.session_state: # Only generate if not already present
#                  with st.spinner("Generating suggestions..."):
#                     suggestions = suggestion_chain.run(
#                         code=st.session_state.generated_code,
#                         language=st.session_state.language, # Use language from state
#                         task=st.session_state.task # Use task from state
#                     )
#                     st.session_state.suggestions = suggestions
#             st.subheader("Suggested Improvements:")
#             st.info(st.session_state.suggestions)
# 
#         elif option == 'Generate code with suggestions':
#             if 'suggestions' in st.session_state:
#                 st.subheader("Generating code with suggestions...")
#                 # Use task and language from state
#                 updated_task = f"{st.session_state.task}\n\nIncorporate the following suggestions:\n{st.session_state.suggestions}"
#                 with st.spinner("Generating updated code..."):
#                     generated_code = code_chain.run(task=updated_task, language=st.session_state.language)
#                     st.session_state.generated_code = generated_code
#                     # Task in state is updated to include suggestions for continuity if needed
#                     st.session_state.task = updated_task
#                     if 'suggestions' in st.session_state:
#                         del st.session_state.suggestions # Clear old suggestions after incorporating
#                 st.subheader("Updated Code:")
#                 st.code(st.session_state.generated_code, language=st.session_state.language)
#             else:
#                 st.warning("Please get suggestions first before generating code with suggestions.")
# 
#         elif option == 'Edit the code manually':
#             st.subheader("Edit the code below:")
#             # Use code from state, store edits back to state
#             edited_code = st.text_area("Edit Code", value=st.session_state.generated_code, height=400, key='edited_code_area')
#             if st.button("Apply Manual Edits"):
#                 st.session_state.generated_code = edited_code
#                 st.success("Code updated with your manual changes.")
#                 # No rerun needed, Streamlit handles update on button click
# 
#         elif option == 'Generate another code':
#             st.subheader("Generate Another Code:")
#             # Provide new input fields for task and language
#             new_task = st.text_area("Enter the new coding task:", key='another_task_input')
#             new_language = st.text_input("Enter the new programming language:", key='another_language_input')
#             if st.button("Generate New Code"):
#                 if new_task and new_language:
#                     with st.spinner("Generating new code..."):
#                         generated_code = code_chain.run(task=new_task, language=new_language)
#                         st.session_state.generated_code = generated_code
#                         st.session_state.task = new_task # Update task and language in state
#                         st.session_state.language = new_language
#                         if 'suggestions' in st.session_state:
#                              del st.session_state.suggestions # Clear old suggestions
#                     st.subheader("Newly Generated Code:")
#                     st.code(st.session_state.generated_code, language=st.session_state.language)
#                 else:
#                     st.warning("Please enter both a new coding task and a programming language.")
# 
# 
#         elif option == 'Let the model make a change you define':
#             st.subheader("Request a Custom Change:")
#             custom_change = st.text_area("Describe the change you want the model to make:", key='custom_change_input')
#             if st.button("Apply Custom Change"):
#                 if custom_change:
#                      # Append custom change to the existing task from state
#                     updated_task_with_custom = f"{st.session_state.task}\n\nUpdate Request: {custom_change}"
#                     with st.spinner("Applying custom change..."):
#                         generated_code = code_chain.run(task=updated_task_with_custom, language=st.session_state.language)
#                         st.session_state.generated_code = generated_code
#                         st.session_state.task = updated_task_with_custom # Update task in state
#                         if 'suggestions' in st.session_state:
#                             del st.session_state.suggestions # Clear old suggestions
#                     st.subheader("Code with Custom Change:")
#                     st.code(st.session_state.generated_code, language=st.session_state.language)
#                 else:
#                     st.warning("Please describe the custom change you want.")
# 
#         elif option == 'Exit/Final Code':
#             st.subheader("Final Code Output:")
#             if 'generated_code' in st.session_state:
#                 st.code(st.session_state.generated_code, language=st.session_state.language)
#             else:
#                 st.info("No code has been generated yet.")
#             st.write("Exiting... Have a productive coding session!")
#

from pyngrok import ngrok
import subprocess
import time

# Terminate open tunnels if any
ngrok.kill()

# Set your authtoken. Replace 'YOUR_NGROK_AUTHTOKEN' with your actual token or use secrets
ngrok.set_auth_token("305YkoBuFAvqGJ0J79jfc2tFHax_6zsdzunjnDm9zyUo3pdQK")

# Run the Streamlit app in the background
process = subprocess.Popen(['streamlit', 'run', 'app.py'])

# Give Streamlit a moment to start
time.sleep(5)

# Open a tunnel to the streamlit port 8501
try:
    public_url = ngrok.connect(addr='8501', proto='http')
    print(f"Streamlit app will be available at: {public_url}")
except Exception as e:
    print(f"An error occurred while trying to connect ngrok: {e}")
    print("Please ensure you have a valid ngrok authtoken and no other ngrok sessions are active.")

# To stop the Streamlit app and ngrok tunnel later, you might need to interrupt the kernel
# or use process.terminate() if you keep track of the process.

